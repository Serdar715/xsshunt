package waf

import (
	"crypto/tls"
	"io"
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"time"
)

// WAFSignature represents a WAF detection signature
type WAFSignature struct {
	Name           string
	HeaderPatterns []string
	CookiePatterns []string
	BodyPatterns   []string
	StatusCodes    []int
}

// Detector handles WAF detection with proxy and auth support
type Detector struct {
	client        *http.Client
	signatures    []WAFSignature
	cookies       string
	customHeaders map[string]string
}

// NewDetector creates a new WAF detector without proxy
func NewDetector() *Detector {
	return NewDetectorWithProxy("", "", nil)
}

// NewDetectorWithProxy creates a new WAF detector with optional proxy and auth support
func NewDetectorWithProxy(proxyURL, cookies string, headers map[string]string) *Detector {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}

	// Configure proxy if provided
	if proxyURL != "" {
		proxyURLParsed, err := url.Parse(proxyURL)
		if err == nil {
			transport.Proxy = http.ProxyURL(proxyURLParsed)
		}
	}

	return &Detector{
		client: &http.Client{
			Timeout:   15 * time.Second,
			Transport: transport,
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		},
		signatures:    getWAFSignatures(),
		cookies:       cookies,
		customHeaders: headers,
	}
}

// getWAFSignatures returns comprehensive WAF detection signatures
func getWAFSignatures() []WAFSignature {
	return []WAFSignature{
		{
			Name: "cloudflare",
			HeaderPatterns: []string{
				"cf-ray",
				"cf-request-id",
				"cf-cache-status",
				"cloudflare",
				"__cfduid",
				"cf-connecting-ip",
			},
			CookiePatterns: []string{
				"__cfduid",
				"cf_clearance",
				"cf_use_ob",
			},
			BodyPatterns: []string{
				"cloudflare",
				"attention required",
				"cf-browser-verification",
				"ray id:",
				"cloudflare ray id",
			},
			StatusCodes: []int{403, 503},
		},
		{
			Name: "akamai",
			HeaderPatterns: []string{
				"akamai",
				"akamai-",
				"x-akamai-",
				"akamaighost",
				"akamai-origin-hop",
			},
			CookiePatterns: []string{
				"akavpau_",
				"akamai_",
				"ak_bmsc",
				"bm_sv",
				"bm_sz",
			},
			BodyPatterns: []string{
				"akamai",
				"access denied",
				"reference#",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "cloudfront",
			HeaderPatterns: []string{
				"x-amz-",
				"x-amzn-",
				"cloudfront",
				"x-cache",
				"via.*cloudfront",
			},
			CookiePatterns: []string{
				"awsalb",
				"awsalbcors",
				"x-amz-",
			},
			BodyPatterns: []string{
				"cloudfront",
				"amazon cloudfront",
				"generated by cloudfront",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "imperva",
			HeaderPatterns: []string{
				"incapsula",
				"x-iinfo",
				"x-cdn",
				"imperva",
			},
			CookiePatterns: []string{
				"incap_ses",
				"visid_incap",
				"nlbi_",
				"incap_ses_",
			},
			BodyPatterns: []string{
				"incapsula",
				"imperva",
				"incap_ses",
				"request unsuccessful",
				"blocked by imperva",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "wordfence",
			HeaderPatterns: []string{
				"x-wordfence",
			},
			CookiePatterns: []string{
				"wfvt_",
				"wordfence",
			},
			BodyPatterns: []string{
				"wordfence",
				"generated by wordfence",
				"your access to this site has been limited",
				"block reason:",
			},
			StatusCodes: []int{403, 503},
		},
		{
			Name: "modsecurity",
			HeaderPatterns: []string{
				"mod_security",
				"modsecurity",
				"nyob",
			},
			CookiePatterns: []string{},
			BodyPatterns: []string{
				"mod_security",
				"modsecurity",
				"not acceptable",
				"this error was generated by mod_security",
				"rules error",
			},
			StatusCodes: []int{403, 406},
		},
		{
			Name: "sucuri",
			HeaderPatterns: []string{
				"x-sucuri-",
				"sucuri",
				"x-sucuri-id",
				"x-sucuri-cache",
			},
			CookiePatterns: []string{
				"sucuri_cloudproxy",
			},
			BodyPatterns: []string{
				"sucuri",
				"sucuri cloudproxy",
				"access denied - sucuri",
				"sucuri websitesecurity",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "f5",
			HeaderPatterns: []string{
				"bigip",
				"f5",
				"x-waf-",
				"ts",
				"x-cnection",
			},
			CookiePatterns: []string{
				"bigipserver",
				"f5_",
				"ts",
				"lastmrh_sess",
				"mrhhits",
			},
			BodyPatterns: []string{
				"bigip",
				"big-ip",
				"f5 networks",
				"the requested url was rejected",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "barracuda",
			HeaderPatterns: []string{
				"barracuda",
				"barra_counter_session",
			},
			CookiePatterns: []string{
				"barra_counter_session",
				"bni_",
			},
			BodyPatterns: []string{
				"barracuda",
				"barracuda networks",
				"you have been blocked",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "aws-waf",
			HeaderPatterns: []string{
				"x-amzn-waf",
				"awswaf",
			},
			CookiePatterns: []string{
				"aws-waf-token",
			},
			BodyPatterns: []string{
				"aws waf",
				"request blocked",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "fortiweb",
			HeaderPatterns: []string{
				"fortiwafsid",
			},
			CookiePatterns: []string{
				"fortiwafsid",
				"cookiesession1",
			},
			BodyPatterns: []string{
				"fortinet",
				"fortiweb",
				"fgd_icon",
			},
			StatusCodes: []int{403},
		},
		{
			Name: "comodo",
			HeaderPatterns: []string{
				"x-cw-",
			},
			CookiePatterns: []string{
				"cprefix",
			},
			BodyPatterns: []string{
				"comodo",
				"protected by comodo",
			},
			StatusCodes: []int{403},
		},
	}
}

// Detect identifies the WAF protecting the target
func (d *Detector) Detect(targetURL string) (string, error) {
	// First, try a clean request to get baseline
	baselineResp, err := d.makeRequest(targetURL)
	if err != nil {
		return "", err
	}
	defer baselineResp.Body.Close()

	baselineBody, _ := io.ReadAll(baselineResp.Body)

	// Check baseline for WAF signatures
	if waf := d.matchSignatures(baselineResp.Header, baselineResp.Cookies(), string(baselineBody), baselineResp.StatusCode); waf != "" {
		return waf, nil
	}

	// Send probe requests with attack payloads to trigger WAF
	probePayloads := []string{
		"<script>alert(1)</script>",
		"' OR 1=1--",
		"../../../etc/passwd",
		"${7*7}",
		"{{7*7}}",
		"<img src=x onerror=alert(1)>",
	}

	for _, payload := range probePayloads {
		probeURL := targetURL + url.QueryEscape(payload)
		probeResp, err := d.makeRequest(probeURL)
		if err != nil {
			continue
		}

		probeBody, _ := io.ReadAll(probeResp.Body)
		probeResp.Body.Close()

		// Check probe response for WAF signatures
		if waf := d.matchSignatures(probeResp.Header, probeResp.Cookies(), string(probeBody), probeResp.StatusCode); waf != "" {
			return waf, nil
		}

		// Check for status code changes that might indicate WAF
		if probeResp.StatusCode == 403 || probeResp.StatusCode == 406 || probeResp.StatusCode == 429 || probeResp.StatusCode == 503 {
			if baselineResp.StatusCode != probeResp.StatusCode {
				// WAF likely blocking, but can't identify which one
				return "unknown", nil
			}
		}
	}

	return "", nil
}

// makeRequest sends an HTTP request with authentication and custom headers
func (d *Detector) makeRequest(targetURL string) (*http.Response, error) {
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, err
	}

	// Set standard headers
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
	req.Header.Set("Connection", "keep-alive")

	// Set cookies if provided
	if d.cookies != "" {
		req.Header.Set("Cookie", d.cookies)
	}

	// Set custom headers if provided
	for key, value := range d.customHeaders {
		req.Header.Set(key, value)
	}

	return d.client.Do(req)
}

// matchSignatures checks response against all WAF signatures
func (d *Detector) matchSignatures(headers http.Header, cookies []*http.Cookie, body string, statusCode int) string {
	bodyLower := strings.ToLower(body)

	for _, sig := range d.signatures {
		// Check headers
		for name, values := range headers {
			headerStr := strings.ToLower(name + ": " + strings.Join(values, ", "))
			for _, pattern := range sig.HeaderPatterns {
				if matchPattern(headerStr, strings.ToLower(pattern)) {
					return sig.Name
				}
			}
		}

		// Check cookies
		for _, cookie := range cookies {
			cookieStr := strings.ToLower(cookie.Name + "=" + cookie.Value)
			for _, pattern := range sig.CookiePatterns {
				if matchPattern(cookieStr, strings.ToLower(pattern)) {
					return sig.Name
				}
			}
		}

		// Check body
		for _, pattern := range sig.BodyPatterns {
			if matchPattern(bodyLower, strings.ToLower(pattern)) {
				return sig.Name
			}
		}
	}

	return ""
}

// matchPattern checks if the text matches the pattern (supports simple regex)
func matchPattern(text, pattern string) bool {
	// Try as simple substring first
	if strings.Contains(text, pattern) {
		return true
	}

	// Try as regex if pattern contains special characters
	if strings.ContainsAny(pattern, ".*+?[]{}|^$()\\") {
		matched, _ := regexp.MatchString(pattern, text)
		return matched
	}

	return false
}
